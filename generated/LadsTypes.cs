/******************************************************************************
**
** <auto-generated>
**     This code was generated by a tool: UaModeler
**     Runtime Version: 1.6.8, using .NET Server 3.2.0 template (version 0)
**
**     Changes to this file may cause incorrect behavior and will be lost if
**     the code is regenerated.
**
**     Generated by gresser <enrico.gresser@brand.de>
** </auto-generated>
**
** Copyright (c) 2006-2023 Unified Automation GmbH All rights reserved.
**
** Software License Agreement ("SLA") Version 2.8
**
** Unless explicitly acquired and licensed from Licensor under another
** license, the contents of this file are subject to the Software License
** Agreement ("SLA") Version 2.8, or subsequent versions
** as allowed by the SLA, and You may not copy or use this file in either
** source code or executable form, except in compliance with the terms and
** conditions of the SLA.
**
** All software distributed under the SLA is provided strictly on an
** "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
** AND LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT
** LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, QUIET ENJOYMENT, OR NON-INFRINGEMENT. See the SLA for specific
** language governing rights and limitations under the SLA.
**
** Project: .NET OPC UA SDK information model for namespace http://opcfoundation.org/UA/LADS/
**
** Description: OPC Unified Architecture Software Development Kit.
**
** The complete license agreement can be found here:
** http://unifiedautomation.com/License/SLA/2.8/
**
** Created: 25.03.2023
**
******************************************************************************/

using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Xml;
using System.Linq;
using System.Runtime.Serialization;
using UnifiedAutomation.UaBase;
using System.Diagnostics;

namespace UnifiedAutomation.Lads
{
    #region MaintenanceTaskStopResultEnum
    /// <summary>
    /// The possible encodings for a MaintenanceTaskStopResultEnum value.
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Lads.Namespaces.LadsXsd)]
    public enum MaintenanceTaskStopResultEnum
    {
        /// <summary>
        /// The maintenance task stopped successfully.
        /// </summary>
        [EnumMember(Value = "Success_0")]
        Success = 0,
        /// <summary>
        /// The maintenance task stopped with failure.
        /// </summary>
        [EnumMember(Value = "Failure_1")]
        Failure = 1,
        /// <summary>
        /// The status of the maintenance task upon stopping cannot be determined.
        /// </summary>
        [EnumMember(Value = "Undetermined_2")]
        Undetermined = 2,
    }

    #region MaintenanceTaskStopResultEnumCollection Class
    /// <summary>
    /// A collection of MaintenanceTaskStopResultEnum objects.
    /// </summary>
    [CollectionDataContract]
    public partial class MaintenanceTaskStopResultEnumCollection : List<MaintenanceTaskStopResultEnum>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public MaintenanceTaskStopResultEnumCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public MaintenanceTaskStopResultEnumCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public MaintenanceTaskStopResultEnumCollection(IEnumerable<MaintenanceTaskStopResultEnum> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator MaintenanceTaskStopResultEnumCollection(MaintenanceTaskStopResultEnum[] values)
        {
            if (values != null)
            {
                return new MaintenanceTaskStopResultEnumCollection(values);
            }

            return new MaintenanceTaskStopResultEnumCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator MaintenanceTaskStopResultEnum[](MaintenanceTaskStopResultEnumCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            MaintenanceTaskStopResultEnumCollection clone = new MaintenanceTaskStopResultEnumCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((MaintenanceTaskStopResultEnum)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion

    #endregion

    #region KeyValueType Class
    /// <summary>
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Lads.Namespaces.LadsXsd)]
    public partial class KeyValueType : IEncodeable
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public KeyValueType()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_Key = null;
            m_Value = null;
        }
        #endregion

        #region Public Properties

        /// <summary>
        /// </summary>
        [DataMember(Name = "Key", IsRequired = false, Order = 1)]
        public string Key
        {
            get
            {
                return m_Key;
            }
            set
            {
                m_Key = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "Value", IsRequired = false, Order = 2)]
        public string Value
        {
            get
            {
                return m_Value;
            }
            set
            {
                m_Value = value;
            }
        }

        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public virtual ExpandedNodeId TypeId
        {
            get { return DataTypeIds.KeyValueType; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public virtual ExpandedNodeId BinaryEncodingId
        {
            get { return ObjectIds.KeyValueType_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public virtual ExpandedNodeId XmlEncodingId
        {
            get { return ObjectIds.KeyValueType_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(Namespaces.LadsXsd);

            encoder.WriteString("Key", Key);
            encoder.WriteString("Value", Value);

            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(Namespaces.LadsXsd);
            Key = decoder.ReadString("Key");
            Value = decoder.ReadString("Value");

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            KeyValueType value = encodeable as KeyValueType;

            if (value == null)
            {
                return false;
            }
            if (!TypeUtils.IsEqual(m_Key, value.m_Key)) return false;
            if (!TypeUtils.IsEqual(m_Value, value.m_Value)) return false;

            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public virtual object Clone()
        {
            KeyValueType clone = (KeyValueType)this.MemberwiseClone();

            clone.m_Key = (string)TypeUtils.Clone(this.m_Key);
            clone.m_Value = (string)TypeUtils.Clone(this.m_Value);

            return clone;
        }
        #endregion

        #region Private Fields
        private string m_Key;
        private string m_Value;
        #endregion
    }

    #region KeyValueTypeCollection class
    /// <summary>
    /// A collection of KeyValueType objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfKeyValueType", Namespace = UnifiedAutomation.Lads.Namespaces.Lads, ItemName = "KeyValueType")]
    public partial class KeyValueTypeCollection : List<KeyValueType>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public KeyValueTypeCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public KeyValueTypeCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public KeyValueTypeCollection(IEnumerable<KeyValueType> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator KeyValueTypeCollection(KeyValueType[] values)
        {
            if (values != null)
            {
                return new KeyValueTypeCollection(values);
            }

            return new KeyValueTypeCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator KeyValueType[](KeyValueTypeCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            KeyValueTypeCollection clone = new KeyValueTypeCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((KeyValueType)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region SampleInfoType Class
    /// <summary>
    /// </summary>
    [DataContract(Namespace = UnifiedAutomation.Lads.Namespaces.LadsXsd)]
    public partial class SampleInfoType : IEncodeable
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public SampleInfoType()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_ContainerId = null;
            m_SampleId = null;
            m_Position = null;
            m_CustomData = null;
        }
        #endregion

        #region Public Properties

        /// <summary>
        /// </summary>
        [DataMember(Name = "ContainerId", IsRequired = false, Order = 1)]
        public string ContainerId
        {
            get
            {
                return m_ContainerId;
            }
            set
            {
                m_ContainerId = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "SampleId", IsRequired = false, Order = 2)]
        public string SampleId
        {
            get
            {
                return m_SampleId;
            }
            set
            {
                m_SampleId = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "Position", IsRequired = false, Order = 3)]
        public string Position
        {
            get
            {
                return m_Position;
            }
            set
            {
                m_Position = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "CustomData", IsRequired = false, Order = 4)]
        public string CustomData
        {
            get
            {
                return m_CustomData;
            }
            set
            {
                m_CustomData = value;
            }
        }

        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public virtual ExpandedNodeId TypeId
        {
            get { return DataTypeIds.SampleInfoType; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public virtual ExpandedNodeId BinaryEncodingId
        {
            get { return ObjectIds.SampleInfoType_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public virtual ExpandedNodeId XmlEncodingId
        {
            get { return ObjectIds.SampleInfoType_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(Namespaces.LadsXsd);

            encoder.WriteString("ContainerId", ContainerId);
            encoder.WriteString("SampleId", SampleId);
            encoder.WriteString("Position", Position);
            encoder.WriteString("CustomData", CustomData);

            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(Namespaces.LadsXsd);
            ContainerId = decoder.ReadString("ContainerId");
            SampleId = decoder.ReadString("SampleId");
            Position = decoder.ReadString("Position");
            CustomData = decoder.ReadString("CustomData");

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            SampleInfoType value = encodeable as SampleInfoType;

            if (value == null)
            {
                return false;
            }
            if (!TypeUtils.IsEqual(m_ContainerId, value.m_ContainerId)) return false;
            if (!TypeUtils.IsEqual(m_SampleId, value.m_SampleId)) return false;
            if (!TypeUtils.IsEqual(m_Position, value.m_Position)) return false;
            if (!TypeUtils.IsEqual(m_CustomData, value.m_CustomData)) return false;

            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public virtual object Clone()
        {
            SampleInfoType clone = (SampleInfoType)this.MemberwiseClone();

            clone.m_ContainerId = (string)TypeUtils.Clone(this.m_ContainerId);
            clone.m_SampleId = (string)TypeUtils.Clone(this.m_SampleId);
            clone.m_Position = (string)TypeUtils.Clone(this.m_Position);
            clone.m_CustomData = (string)TypeUtils.Clone(this.m_CustomData);

            return clone;
        }
        #endregion

        #region Private Fields
        private string m_ContainerId;
        private string m_SampleId;
        private string m_Position;
        private string m_CustomData;
        #endregion
    }

    #region SampleInfoTypeCollection class
    /// <summary>
    /// A collection of SampleInfoType objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfSampleInfoType", Namespace = UnifiedAutomation.Lads.Namespaces.Lads, ItemName = "SampleInfoType")]
    public partial class SampleInfoTypeCollection : List<SampleInfoType>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public SampleInfoTypeCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public SampleInfoTypeCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public SampleInfoTypeCollection(IEnumerable<SampleInfoType> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator SampleInfoTypeCollection(SampleInfoType[] values)
        {
            if (values != null)
            {
                return new SampleInfoTypeCollection(values);
            }

            return new SampleInfoTypeCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator SampleInfoType[](SampleInfoTypeCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            SampleInfoTypeCollection clone = new SampleInfoTypeCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((SampleInfoType)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion


    #region EncodeableTypes
    /// <summary>
    /// Contains a method for registering all encodeable types of the namespace.
    /// </summary>
    public class EncodeableTypes
    {
        /// <summary>
        /// Register all encodeable types of the namespace at the communication stack.
        /// The Decoder will decode the registered types.
        /// </summary>
        public static void RegisterEncodeableTypes(MessageContext context)
        {
            context.Factory.AddEncodeableType(typeof(UnifiedAutomation.Lads.KeyValueType));
            context.Factory.AddEncodeableType(typeof(UnifiedAutomation.Lads.SampleInfoType));
        }
    }
    #endregion
}
